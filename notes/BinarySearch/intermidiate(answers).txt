note:
    if low and high have diff polarity they will change to their opposite
        polarities at the end of binarySearch

problems:
    square root of a number:
        if mid*mid>number:
            consider the left half
        if mid*mid<number:
            consider the mid as temp ans
            consider the right half
    find the nth root of a number:
        find a ans whose nth power = number
        range lies b/w 1 to number
        find mid if pow(mid,n)==m:
            return mid;
        if at any point in the pow(mid,n)>m:
            high=mid-1
        else:
            low=mid+1
    Koko eating bananas:
        find the min bananas he can eat to finish an array of bananas within a specified amount of time
        the max will be the max ele of array
            because we consider ceil of arr[i]/eat
        min will be min ele of array
        find mid if mid eating bananas hours<=specified hours:
            store the ans and move to left half
        else:
            move to right half
    min days to make m bouquets:
        we can only take consequent array elements
        consider min and max from the array
        find mid if mid days blooming of n consequent flowers occurs >=m:
            consider mid as ans and move to left half
        else:
            move to right half
    find the smallest divisor:
        we can only consider consequent array elements
        range from 1 to max array element
        find mid divide all array elements and consider ceil
        if <= threshold:
            consider the element and move left half
        else:
            move to right half
    Capacity to ship packages within D days:
        we can only consider consequent array elements
        note : range from max element to sum of all elements
        find mid calculate number of days for mid
        if <= threshold days:
            consider the element and move to left half
        else:
            move to right half
    Kth missing positive number:
        find mid and missing
        missing = consider a array with same Capacity and without any element missing
        based on the what element is their and what should have been
            find out the missing elements upto that index
        low and high endup in opposite polarity
        k is b/w high and low :
            if u observe arr[high] + more gives the ans
                where more = k - missing
            this can't be an ideal solution because if high = -ve
            so = arr[high] + more
            = arr[high] + k - missing
            = arr[high] + k - (arr[high] - (high +1))
            = k + high + 1 or k + low
    min of max problems:
    Aggressive cows:
        place the cows in a array with co-ordinates such that
            the max distance b/w the cows is min
        the range is from 1 to max distance which is last ele- first ele since sorted
        find mid and no of cows which can come under this distance
        if no of cows>=threshold
            consider the ans and move to right half
        else:
            move to left half
    Allocate Books:
        given an array with books at index and its pages as value
        the books to be distributed among number of students
        rules : no books left, atleast 1 book/student
        find the max pages Allocated to a stu which is min
        range from max in array to sum of array
        find mid and Allocate books
        if all books Allocated to students:
            consider the ans and move to left half
        else:
            move to right half
    painter's partition:
        similar to Allocate books
    minimize max distance b/w gas stations:
        ans is double value with comparison upto 1^-6 demical places with the og testCase output
        better solution:
            make sure to use double dataType where ever needed
            Approach 1:
                priorityQueue(PQ) that takes the distance b/w the og cylinders and their index
                    we take priorityQueue Cause it auto sorts the elements in order we prefer, for our case Desc
                Array marking the cylinders to be placed(lets refer them as virtual cylinders) b/w the og cylinders
                note: point to remember the og cylinder position can't be changed but can change the virtual cylinders position
                Since it's a queue which follows(FIFO) we pop() the latest max distance(max Section distance) and at what index it is present
                through the index using the array we see weather we have placed any virtual cylinders b/w max distance
                if yes: then we can re-arrange its position such that the max Section is equally divided among the max distance
                else: we can simply place the cylinder at mid to equally divide the max Section
                    virtualCylinders[index]++
                    new max section distance= originalGap(using the PQ index)/(virtualCylinders[index]
                        +1(Cause n cylinders in b/w max distance divides it into n+1 sections))
                now add the new section distance and index to the PQ
                perform this until all the virtualCylinders have been placed and get the max Section distance
            Approach 2:
                array that keeps track of the cylinders b/w the checkpoints
                priority queue of obj's keeping the distance b/w the cylinders according to array elements using index
                    it always returns the max element
                place distance and their index in priority queue and create a array
                pop the top element from the PQ(priority queue) get distance and cylinders b/w them using the array
                do distance*(array(cylinders)+1)/array(cylinders)+2 to get new distance by placing the new cylinder
                update no of cylinders in the array
                return the top
        optimal solution:
            can we place given cylinders b/w the present cylinders
            range from 0 to max consecutive diff
            while((high-low)>=1^-6):
                find mid and the number of gas stations can be placed with mid distance
                if gas stations<=given stations:
                    consider the mid
                    update high to mid not mid-1
                else:
                    update low to mid
    median of 2 sorted arrays:
        better solution:
            keep a count variable to track the index of combined array
            when new array length is even:
                consider (arr[mid] + arr[mid-1])/2 to find median
            when odd:
                consider arr[mid]
        optimal solution:
            consider the length of shortest array
            range from 0 to arr.length
            if array is even:
                mid = (n1 + n2)/2
            else:
                mid = (n1 + n2 + 1)/2
            find mid1 from arr1:
                consider mid2=mid-mid1 element from arr2
                l2=mid1 and r2=mid2 and l1=mid1-1 and r1=mid2-1
                if r1>l2 and r2>l1:
                    if n is even:
                        (max(l1,l2)+min(r1,r2))/2
                    else:
                        max(l1,l2)
                if l1>r2:
                    high1 = mid1 - 1
                else(if l2>r1):
                    low1 = mid1 + 1
    kth element of the sorted array:
        consider the length of shortest array =n2
        find mid1 such that range from max(0,k-n2) to min(k,n1)
        mid2 = k -mid1
        add r1=mid1, r2 = mid2, l1=mid1-1 and l2=mid2-1
        if r2>l1 and r1>l2:
            max(l1, l2)
        if l1>r2:
            high1 = mid1-1
        else:
            low1 = mid1+1
    
            







    

    

