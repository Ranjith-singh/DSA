note:
    if low and high have diff polarity they will change to their opposite
        polarities at the end of binarySearch

problems:
    square root of a number:
        if mid*mid>number:
            consider the left half
        if mid*mid<number:
            consider the mid as temp ans
            consider the right half
    find the nth root of a number:
        find a ans whose nth power = number
        range lies b/w 1 to number
        find mid if pow(mid,n)==m:
            return mid;
        if at any point in the pow(mid,n)>m:
            high=mid-1
        else:
            low=mid+1
    Koko eating bananas:
        find the min bananas he can eat to finish an array of bananas within a specified amount of time
        the max will be the max ele of array
            because we consider ceil of arr[i]/eat
        min will be min ele of array
        find mid if mid eating bananas hours<=specified hours:
            store the ans and move to left half
        else:
            move to right half
    min days to make m bouquets:
        we can only take consequent array elements
        consider min and max from the array
        find mid if mid days blooming of n consequent flowers occurs >=m:
            consider mid as ans and move to left half
        else:
            move to right half
    find the smallest divisor:
        we can only consider consequent array elements
        range from 1 to max array element
        find mid divide all array elements and consider ceil
        if <= threshold:
            consider the element and move left half
        else:
            move to right half
    Capacity to ship packages within D days:
        we can only consider consequent array elements
        note : range from max element to sum of all elements
        find mid calculate number of days for mid
        if <= threshold days:
            consider the element and move to left half
        else:
            move to right half
    Kth missing positive number:
        find mid and missing
        missing = consider a array with same Capacity and without any element missing
        based on the what element is their and what should have been
            find out the missing elements upto that index
        low and high endup in opposite polarity
        k is b/w high and low :
            if u observe arr[high] + more gives the ans
                where more = k - missing
            this can't be an ideal solution because if high = -ve
            so = arr[high] + more
            = arr[high] + k - missing
            = arr[high] + k - (arr[high] - (high +1))
            = k + high + 1 or k + low
    min of max problems:
    Aggressive cows:
        place the cows in a array with co-ordinates such that
            the min distance b/e the cows is max
        the range is from 1 to max distance which is last ele- first ele since sorted
        find mid and no of cows which can come under this distance
        if no of cows>=threshold
            consider the ans and move to right half
        else:
            move to left half
    Allocate Books:
        given an array with books at index and its pages as value
        the books to be distributed among number of students
        rules : no books left, atleast 1 book/student
        find the max pages Allocated to a stu which is min
        range from max in array to sum of array
        find mid and Allocate books
        if all books Allocated to students:
            consider the ans and move to left half
        else:
            move to right half
    painter's partition:
        similar to Allocate books
    minimize max distance b/w gas stations:
        ans is double value with consideration upto 10^-6
        better solution:
            array that keeps track of the cylinders b/w the checkpoints
            priority queue of obj's keeping the distance b/w the cylinders according to array elements using index
                it always returns the max element
            place distance and their index in priority queue and create a array
            pop the top element from the PQ(priority queue) get distance and cylinders b/w them using the array
            do distance*(array(cylinders)+1)/array(cylinders)+2 to get new distance by placing the new cylinder
            update no of cylinders in the array
            return the top
        optimal solution:
            can we place given cylinders b/w the present cylinders
            range from 0 to max consecutive diff 
            while((high-low)>=10^-6):
                find mid and the number of gas stations can be placed with mid distance
                if gas stations<=given stations:
                    consider the mid
                    update high to mid not mid-1
                else:
                    update low to mid
    median of 2 sorted arrays:
        better solution:
            keep a count variable to track the index of combined array
            when new array length is even:
                consider (arr[mid] + arr[mid-1])/2 to find median
            when odd:
                consider arr[mid]
        optimal solution:
            consider the length of shortest array
            range from 0 to arr.length
            if array is even:
                mid = (n1 + n2)/2
            else:
                mid = (n1 + n2 + 1)/2
            find mid1 from arr1:
                consider mid2=mid-mid1 element from arr2
                l2=mid1 and r2=mid2 and l1=mid1-1 and r1=mid2-1
                if r1>l2 and r2>l1:
                    if n is even:
                        (max(l1,l2)+min(r1,r2))/2
                    else:
                        max(l1,l2)
                if l1>r2:
                    high1 = mid1 - 1
                else(if l2>r1):
                    low1 = mid1 + 1
    kth element of the sorted array:
        consider the length of shortest array =n2
        find mid1 such that range from max(0,k-n2) to min(k,n1)
        mid2 = k -mid1
        add r1=mid1, r2 = mid2, l1=mid1-1 and l2=mid2-1
        if r2>l1 and r1>l2:
            max(l1, l2)
        if l1>r2:
            high1 = mid1-1
        else:
            low1 = mid1+1
    
            







    

    

