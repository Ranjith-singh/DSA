types of trees:
    Full BinaryTree:
        children should be 0 or 2
    complete BinaryTree:
        all levels are filled except last level
        last level filling should be from left
    perfect BinaryTree:
        Full BinaryTree + complete BinaryTree
        internal nodes should have 2 children and left nodes should have same depth
    Balanced BinaryTree:
        height diff b/w the left and right subTree of any node should be atmost 1
    Degenerate BinaryTree:
        each node has only 1 child similar to linked list

tree traversals:
    preorder traversal(Root-left-right):
        recursive:
            check if root==null:
                return
            else:
                print root.data
                call preorder for root.left and root.right
        iterative:
            create a stack and add the root node to it
            while stack is not empty:
                root = stack.pop()
                check if root == null
                    continue;
                print root.data
                add root.right and root.left to the stack
    Inorder traversal(left-root-right)
        recursive:
            check if root==null
                return
            call Inorder for root.left
            print root.data
            call Inorder for root.right
        iterative:
            create a stack for Nodes
            while(true):
                if root!=null:
                    add root to stack and move left part
                else:
                    check if stack.isEmpty():
                        break;
                    root = stack.pop()
                    print root.data and move to right part
            approach :
                when null occurs on the left part:
                    we consider the left part as sorted
                    print root data and move to right part
                when their is no right part we move to parent of the root through stack
    Postorder traversal:
        recursive:
            check if root==null:
                return
            call the Postorder for left and right parts
            print the root.data
        iterative:
            2 stack:
                create 2 stacks and add the root to the first stack
                while stack1 is not empty:
                    pop stack1 assign it to root and add to stack2
                    check if root left and right are not null then add them to stack resp
                print the nodes from stack2 using stack2.pop till it is empty
            1 stack:
                create a stack and check while root!=null || !stack.isEmpty()
                    if root!=null:
                        add root to stack and move to left part
                    else:
                        check if the top element of stack has right part using temp
                        if yes:
                            assign right part to root
                        else:
                            this is the leaf node
                            print the stack.pop() data
                            while stack is not empty and temp = stack.top().right:
                                print temp and assign temp = stack.pop()
                approach:
                    move to extreme leaf of the tree
                    when it reaches null print check for right part
                    if right part exists move to right part
                    if no right part print the root data
                    then check if root is the right part of its parent
                    if yes:
                        print the parent data since right part is executed using stack
                    else:
                        check if it has any right part
                        if yes:
                            assign it to root
                        else:
                            print parent data and move to GrandParent using stack






